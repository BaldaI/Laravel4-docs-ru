# Безопасность

- [Настройка](#configuration)
- [Хранение паролей](#storing-passwords)
- [Авторизация пользователей](#authenticating-users)
- [Ручная авторизация](#manually)
- [Защита маршрутов](#protecting-routes)
- [Простая HTTP-авторизаци](#http-basic-authentication)
- [Сброс и изменение паролей](#password-reminders-and-reset)
- [Шифрование](#encryption)

<a name="configuration"></a>
## Настройка

Laravel стремиться сделать реализацию авторизации максимально простой. Фактически, почти всё уже настроено после установки. Настройки хранятся в файле `app/config/auth.php`, который содержит несколько хорошо документированных параметров для настройки поведения методов авторизации.

По умолчанию Laravel включает в себя модель `User` в папке `app/models`, которая может использоваться вместе с драйвером авторизации Eloquent (по умолчанию). При создании таблицы для данной модели убедитесь, что поле пароля принимает как минимум 0 символов.

Если ваше приложение не использует Eloquent, вы можете использовать драйвер `database`, который использует конструктор запросов Laravel.

<a name="storing-passwords"></a>
## Хранение паролей

Класс `Hash` содержит методы для безопасного хэширования с помощью Bcrypt.

**Хэширование пароля по алгоритму Bcrypt:**

	$password = Hash::make('secret');

**Проверка пароля по хэшу:**

	if (Hash::check('secret', $hashedPassword))
	{
		// Пароль подходит...
	}

**Проверка на необходимость перехэширования пароля:**

	if (Hash::needsRehash($hashed))
	{
		$hashed = Hash::make('secret');
	}

<a name="authenticating-users"></a>
## Авторизация пользователей

Для авторизации пользователя в вашем приложении используется метод `Auth::attempt`.

	if (Auth::attempt(array('email' => $email, 'password' => $password)))
	{
		return Redirect::intended('dashboard');
	}

Заметьте, что поле `email` не обязательно и оно используется только для примера. Вы должны использовать любое поле, которое соответствует имени пользователя в вашей БД. Метод `Redirect::intended` отправит пользователя на URL, который он пытался просмотреть до того, как запрос был перехвачен фильтром авторизации. Дополнительный URL может быть передан в метод, если требуемый адрес не доступен.

Когда вызывается метод `attempt` возбуждается [событие](/docs/events) `auth.attempt`. При успешной авторизации также произойдёт событие `auth.login`.

Для определения того, авторизован ли пользователь или нет, можно использовать метод `check.

**Проверка авторизации пользователя:**

	if (Auth::check())
	{
		// Пользователь уже вошёл в систему...
	}

Если вы хотите предоставить функциональность типа "запомнить меня", то вы можете передать `true` вторым параметром к методу `attempt`, который будет поддерживать авторизацию пользователя без ограничения по времени (пока он вручную не выйдет из системы).

**Авторизация и запоминание пользователя:**

	if (Auth::attempt(array('email' => $email, 'password' => $password), true))
	{
		// Пользователь был запомнен...
	}

**Внимание:** если метод `attempt` вернул `true`, то пользователь успешно вошёл в систему.

Вы также можете передать дополнительные условия для запроса к таблице.

**Авторизация пользователя с условиями:**

    if (Auth::attempt(array('email' => $email, 'password' => $password, 'active' => 1)))
    {
        // Вход, если пользователь активен, не отключен и существует.
    }

Как только пользователь авторизован вы можете обращаться к модели `User` и её свойствам.

**Доступ к авторизованному пользователю:**

	$email = Auth::user()->email;

Для простой авторизации пользователя по ID используется метод `loginUsingId`:

	Auth::loginUsingId(1);

Метод `validate` позволяет вам проверить данные для входа без осуществления самого входа.

**Проверка данных для входа без авторизации:**

	if (Auth::validate($credentials))
	{
		//
	}

Вы также можете использовать метод `once` для авторизации пользователя в системе только для одного запроса. Сессии и cookies не будут использованы.

**Авторизация пользоваля на один запрос:**

	if (Auth::once($credentials))
	{
		//
	}

**Выход пользователя из системы:**

	Auth::logout();

<a name="manually"></a>
## Ручная авторизация

Если вам нужно авторизовать существующего пользователя просто передайте его модель в метод `login`:

	$user = User::find(1);

	Auth::login($user);

Это эквивалентно авторизации пользвоателя через его данные методом `attempt`.

<a name="protecting-routes"></a>
## Защита маршрутов

Вы можете использовать Фильтры маршрутов, чтобы позволишь только авторизованным пользователям обращаться к данному маршруту. Изначально Laravel содержит фильтр `auth`, который содержится в файле `app/filters.php`.

**Защита маршрута:**

	Route::get('profile', array('before' => 'auth', function()
	{
		// Доступно только авторизованным пользователям...
	}));

### Защита от подделки запросов (CSRF)

Laravel предоставляет простой способ защиты вашего приложения от подделки межсайтовых запросов CSRF.

**Вставка CSRF-ключа в форму:**

    <input type="hidden" name="_token" value="<?php echo csrf_token(); ?>">

**Проверка переданного CSRF-ключа:**

    Route::post('register', array('before' => 'csrf', function()
    {
        return 'Вы передали верный ключ!';
    }));

<a name="http-basic-authentication"></a>
## Простая HTTP-авторизация

HTTP Basic Authentication - простой и быстрый способ авторизовать пользователей вашего приложения без создания дополнительной страницы входа. Для начала подключите фильтр `auth.basic`.

**Защита маршрута фильтром HTTP-авторизации:**

	Route::get('profile', array('before' => 'auth.basic', function()
	{
		// Доступно только авторизованным пользователям...
	}));

По умолчанию, фильтр `basic` будет использовать поле `email` модели объекта при авторизации. Если вы хотите использовать иное поле, можно передать его имя первым параметром методу `basic`:

	return Auth::basic('username');

Вы можете использовать HTTP-авторизацию без установки cookies в сессии, что особенно удобно для авторизации в API. Для того, чтобы сделать это, зарегистрируйте фильтр, вовращающий результат вызова `onceBasic`.

**Авторизация без запоминание состояния:**

	Route::filter('basic.once', function()
	{
		return Auth::onceBasic();
	});

<a name="password-reminders-and-reset"></a>
## Сброс и изменение паролей

### Отправка письма о сбросе

Большая часть приложений позволяют пользователям сбрасывать свои забытые пароли. Вместо того, чтобы заставлять вам реализовывать эту функциональность в каждом приложении, Laravel предоставляет удобный способ для отправки писем о сбросе пароля и выполнения самого сброса. Для начала убедитесь, что модель `User` реализует интерфейс `Illuminate\Auth\Reminders\RemindableInterface`. Это уже сделано для `User`, включённой в фреймворк по умолчанию.

**Реализация интерфейса `RemindableInterface`:**

	class User extends Eloquent implements RemindableInterface {

		public function getReminderEmail()
		{
			return $this->email;
		}

	}

Затем вам нужно создать таблицу для хранения ключей сброса паролей. Для создания миграции для таблицы просто выполните команду `auth:reminders` интерфейса Artisan.

**Генерация миграции для таблиц сброса паролей:**

	php artisan auth:reminders

	php artisan migrate

Для отправки уведомления вы можете использовать метод `Password::remind`.

**Отправка уведомления о сбросе пароля:**

	Route::post('password/remind', function()
	{
		$credentials = array('email' => Input::get('email'));

		return Password::remind($credentials);
	});

Заметьте, что параметры, переданные в метод `remind`, похожи на те, которые передаются методу `Auth::attempt`. Этот метод получит модель `User` и отправит соответствующее письмо со ссылкой для сброса. В шаблон письма будет передана переменная `token`, которая может быть использвоана для изменения пароля через форму его сброса. Кроме неё будет также передана переменная `user`.

> **Внимание:** вы можете указать, какой шаблон должен использоваться при создании сообщения, изменив настройку приложения `auth.reminder.email`. Изначально фреймворк уже содержит нужный шаблон.

Вы можете изменить объект письма, которое отправляется пользователю, передав замыкание в виде второго аргумента методу `remind`:

	return Password::remind($credentials, function($message, $user)
	{
		$message->subject('Ваше уведомление о сбросе.');
	});

Как вы можете заметить, в маршруте мы напрямую возвращаем результат вызова метода `remind`. По умолчанию этот метод возвращает переадресацию на текущий адрес, если возникла ошибка при сбросе пароля, при этом устанавливается одноразовая переменная `error`, а также `reason`, которая используется для извлечения языковой строки из языкового файла `reminders`. Если пароль был успешно сброшен, то будет установлена одноразовая переменная `success`. Таким образом, шаблон для формы сброса пароля должен выглядеть примерно так:

	@if (Session::has('error'))
		{{ trans(Session::get('reason')) }}
	@elseif (Session::has('success'))
		На ваш e-mail было отправлено письмо с инструкциями о сбросе пароля.
	@endif

	<input type="text" name="email">
	<input type="submit" value="Отправить письмо">

### Сброс пароля

Как только пользователь перешёл по ссылке в письме, он будет перенаправлен на форму со скрытым ключом `token`, а также полями `password` и `password_confirmation`. Ниже - пример маршрута для формы сброса:

	Route::get('password/reset/{token}', function($token)
	{
		return View::make('auth.reset')->with('token', $token);
	});

А сама форма может выглядеть так:

	@if (Session::has('error'))
		{{ trans(Session::get('reason')) }}
	@endif

	<input type="hidden" name="token" value="{{ $token }}">
	<input type="text" name="email">
	<input type="password" name="password">
	<input type="password" name="password_confirmation">

Обратите внимание, что мы снова используем `Session` для отображения ошибки, которая могла произойти при сбросе пароля. Дальше мы определяем POST-маршрут, который и произведёт сброс:

	Route::post('password/reset/{token}', function()
	{
		$credentials = array('email' => Input::get('email'));

		return Password::reset($credentials, function($user, $password)
		{
			$user->password = Hash::make($password);

			$user->save();

			return Redirect::to('home');
		});
	});

При успешном сбросе объект `User` и пароль будут переданы в замыкание, что позволит вам сохранить изменённую модель. После этого вы можете вернуть объект `Redirect` или любой другой тип ответа, что и будет возвращено методом `reset`. Заметьте, что этот метод автоматически проверяет переданный ключ `token`, данные для входа и совпадение введённых паролей.

Также, по аналогии с методом `remind`, если во время сброса произошла ошибка метод `reset` вернёт объект `Redirect` на текущий адрес с одноразовыми переменными `error` и `reason`.

<a name="encryption"></a>
## Шифрование

Laravel предоставляет функции для устойчивого шифрование по алгоритму AES-256 с помощью расширения mcrypt для PHP.

**Шифрование строки:**

	$encrypted = Crypt::encrypt('секрет');

> **Внимание:** обязательно установите 32-значный ключ `key` в файле `app/config/app.php`. Если этого не сделать, зашифрованные строки не будут безопасными.

**Расшифровка строки:**

	$decrypted = Crypt::decrypt($encryptedValue);

You may also set the cipher and mode used by the encrypter:

**Изменение алгоритма и режима шифрования:**

	Crypt::setMode('ctr');

	Crypt::setCipher($cipher);
