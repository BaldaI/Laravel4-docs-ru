== Очереди ==
{{Meta автор=из официальной документации, переводчик=Proger_XP, id переводчика=2, обновление=19.08.2013}}
{{Meta оригинал=doc4:queues}}

{{TOC}}

== Настройка ==
В Laravel, компонент Queue предоставляет единое API для различных сервисов очередей. Очереди позволяют вам отложить выполнение времязатратной задачи, такой как отправка e-mail, на более позднее время, таким образом на порядок ускоряя загрузку (генерацию) страницы.

Настройки очередей хранятся в файле %%(t)app/config/queue.php%%. В нём вы найдёте настройки для драйверов-связей, которые поставляются вместе с фреймворком: ((http://kr.github.com/beanstalkd Beanstalkd)), ((http://iron.io/ IronMQ)), ((http://aws.amazon.com/sqs Amazon SQS)), а также синхронный драйвер (для локального использования).

Упомянутые выше драйвера имеют следующие зависимости:
  * **Beanstalkd:** %%(t)pda/pheanstalk%%
  * **Amazon SQS:** %%(t)aws/aws-sdk-php%%
  * **IronMQ:** %%(t)iron-io/iron_mq%%

== Основы использования ==
**Добавление новой задачи в очередь:**
%%
  Queue::push('SendEmail', array('message' => $message));
%%

Первый аргумент метода %%Queue::push()%% - имя класса, который должен использоваться для обработки задачи. Второй аргумент - массив параметров, которые будут переданы обработчику.

**Регистрация обработчика задачи:**
%%
class SendEmail {

    public function fire($job, $data) {
      //
    }

  }
%%

Заметьте, что %%fire()%% - единственный обязательный метод этого класса; он получает экземпляр объект %%Job%% и массив данных, переданных при добавлении задачи в очередь.

Если вы хотите использовать какой-то другой метод вместо %%(t)fire%% - передайте его имя при добавлении задачи.

**Задача с произвольным методом-обработчиком:**
%%
  Queue::push('SendEmail@send', array('message' => $message));
%%

Как только вы закончили обработку задачи она должна быть удалена из очереди - это можно сделать методом %%delete()%% объекта %%Job%%.

**Удаление выполненной задачи:**
%%
  public function fire($job, $data) {
    // Обработка задачи...

    $job->delete();
  }
%%

Если вы хотите поместить задачу обратно в очередь - используйте метод %%release()%%.

**Помещение задачи обратно в очередь:**
%%
  public function fire($job, $data) {
    // Обработка задачи...

    $job->release();
  }
%%

Вы также можете указать число секунд, после которого задача будет помещена обратно:
%%
  $job->release(5);
%%

Если во время обработки задания возникнет исключение, задание будет помещено обратно в очередь. Вы можете получить число сделанных попыток запуска задания методом %%attempts()%%.

**Получение числа попыток запуска задания:**
%%
  if ($job->attempts() > 3) {
    //
  }
%%

**Получение идентификатора задачи:**
%%
  $job->getJobId();
%%

== Добавление замыканий ==
Вы можете помещать в очередь и функции-замыкания. Это очень удобно для простых, быстрых задач, выполняющихся в очереди.

**Добавление замыкания в очередь:**
%%
  Queue::push(function ($job) use ($id) {
    Account::delete($id);

    $job->delete();
  });
%%

.(alert)
**Внимание:** константы %%__DIR__%% и %%__FILE__%% не должны использоваться в замыканиях.

При использовании ((#push push-очередей)) //Iron.io// будьте особенно внимательны при добавлении замыканий. Конечная точка выполнения, получающая ваше сообщение, должна проверить входящую последовательность-ключ, чтобы удостовериться, что запрос действительно исходит от //Iron.io//. Например, ваша конечная push-точка может иметь адрес вида %%(t)https://yourapp.com/queue/receive?token=SecretToken%% - где значение **token** можно проверять перед собственно обработкой задачи.

== Работа сервера приёма очереди ==
Laravel включает в себя задание ((artisan Artisan)), которое будет выполнять новые задачи по мере их поступления. Вы можете запустить его командой %%(t) queue:listen%%.

**Запуск сервера приёма:**
%%(sh)
  php artisan queue:listen
%%

Вы также можете указать, какое именно соединение должно прослушиваться:
%%(sh)
  php artisan queue:listen connection
%%

Заметьте, что когда это задание запущено оно будет продолжать работать, пока вы не остановите его вручную. Вы можете использовать монитор процессов, такой как ((http://supervisord.org/ Supervisor)), чтобы удостовериться, что задание продолжает работать.

Кроме этого, вы можете указать число секунд, в течении которых будут выполняться задачи.

**Указание числа секунд для работы сервера:**
%%(sh)
  php artisan queue:listen --timeout=60
%%

Для обработки только первой задачи можно использовать команду %%(t)queue:work%%.

**Обработка только первой задачи в очереди:**
%%(sh)
  php artisan queue:work
%%

== ((#push)) Push-очереди ==
Push-очереди дают вам доступ ко всем мощным возможностям, предоставляемым подсистемой очередей Laravel 4 без запуска серверов или фоновых программ. На текущий момент push-очереди поддерживает только драйвер //Iron.io//. Перед тем, как начать, создайте аккаунт и впишите его данные в %%(t)app/config/queue.php%%.

После этого вы можете использовать команду %%(t)queue:subscribe%% ((artisan Artisan)) для регистрации URL конечной точки, которая будет получать добавляемые в очередь задачи.

**Регистрация подписчика push-очереди:**
%%(sh)
  php artisan queue:subscribe queue_name http://foo.com/queue/receive
%%

Теперь, когда вы войдёте в ваш профиль //Iron.io//, то увидите новую push-очередь и её URL подписки. Вы можете подписать любое число URL на одну очередь. Дальше создайте маршрут для вашей конечной точки %%(t)queue/receive%% и пусть он возвращает результат вызова метода %%Queue::marshal()%%:
%%
  Route::post('queue/receive', function () {
    return Queue::marshal();
  });
%%

Этот метод позаботится о вызове нужного класса-обработчика задачи. Для помещения задач в push-очередь просто используйте всё тот же метод %%Queue::push()%%, который работает и для обычных очередей.