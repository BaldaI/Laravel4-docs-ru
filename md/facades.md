# Фасады

- [Введение](#introduction)
- [Описание](#explanation)
- [Практическое использование](#practical-usage)
- [Создание фасадов](#creating-facades)
- [Фасады-заглушки](#mocking-facades)

<a name="introduction"></a>
## Введение

Фасады предоставляют "статический" интерфейс к классам, доступным в [контейнере IoC](/docs/ioc). Laravel поставляется со множеством фасадов и вы, вероятно, использовали их, даже не подозревая об этом.

Иногда вам может понадобиться создать собственные фасады для вашего приложения и пакетов (packages), поэтому давайте изучим идею, разработку и использование этих классов.

> **Внимание:** перед погружением в фасады настоятельно рекомендуется как можно детальнее изучить [контейнер IoC](/docs/ioc).

<a name="explanation"></a>
## Описание

В контексте приложения на Laravel, фасад - это класс, который предоставляет доступ к объекту в контейнере. Весь этот механизм реализован в классе `Facade. Фасады как Laravel, так и ваши собственные, наследуют этот базовый класс.

Ваш фасад должен определить единственный метод: `getFacadeAccessor`. Его задача - определить, что вы хотите получить из контейнера. Класс `Facade` использует магический метод PHP `__callStatic()` для перенаправления вызовов методов с вашего фасаде на полученный объект.

<a name="practical-usage"></a>
## Практическое использование

В примере ниже делается обращение к механизму кэширования Laravel. На первый взгляд может показаться, что метод `get` принадлежит классу  `Cache`.

	$value = Cache::get('key');

Однако, если вы посмотрите в исходный код класса `Illuminate\Support\Facades\Cache`, то увидите, что он не содержит метода `get`:

	class Cache extends Facade {

		/**
		 * Получить зарегистрированное имя компонента.
		 *
		 * @return string
		 */
		protected static function getFacadeAccessor() { return 'cache'; }

	}

Класс Cache наследует класс `Facade` и определяет метод `getFacadeAccessor()`. Как вы помните, его задача - вернуть имя привязки (типа) в контейнере IoC.

Когда вы обращаетесь к любому статическому методу фасада `Cache`, Laravel получает объект `cache`из IoC и вызывает на нём требуемый метод (в этом случае - `get`).

Таким образом, вызов `Cache::get` может быть записан так:

	$value = $app->make('cache')->get('key');

<a name="creating-facades"></a>
## Создание фасадов

Создать фасад в вашем приложении или пакете (package) довольно просто. Вам нужны только три вещи:

1. Связка в IoC.
2. Класс-фасад.
3. Настройка для псевдонима фасада.

Посмотрим на следующий пример. Здесь определён класс `PaymentGateway\Payment`.

	namespace PaymentGateway;

	class Payment {

		public function process()
		{
			//
		}

	}

Нам нужно, чтобы этот класс извлекался из контейнера IoC, так что давайте добавим для него привязку (binding):

	App::bind('payment', function()
	{
		return new \PaymentGateway\Payment;
	});

Самое лучшее место для регистрации этой связки - новый [поставщики поставщик услуг](/docs/ioc#service-providers) который мы назовём `PaymentServiceProvider`и в котором мы создадим метод `register`, содержащий код выше. После этого вы можете настроить Laravel для загрузки этого поставщика в файле `app/config/app.php`.

Дальше мы можем написать класс нашего фасада:

	use Illuminate\Support\Facades\Facade;

	class Payment extends Facade {

		protected static function getFacadeAccessor() { return 'payment'; }

	}

Наконец, по желанию можно добавить псевдоним (alias) для этого фасада в массив `aliases` файла настроек `app/config/app.php`- тогда мы сможем вызывать метод `process` на классе `Payment`.

	Payment::process();

### Об автозагрузке псевдонимов

В некоторых случаях классы в массиве `aliases` не доступны из-за того, что [PHP не загружает неизвестные классы в подсказках типов](https://bugs.php.net/bug.php?id=39003). Если `\ServiceWrapper\ApiTimeoutException` имеет псевдоним `ApiTimeoutException`, то блок `catch(ApiTimeoutException $e)`, помещённый в любое пространство имён, кроме `\ServiceWrapper`, никогда не "поймает" это исключение, даже если оно было возбуждено внутри него. Аналогичная проблема возникает в моделях, которые содержат подсказки типов на неизвестные (неопределённые) классы. Единственное решение - не использовать псевдонимы и вместо них в начале каждого файла писать `use` для классов, которые вы хотите использовать в подсказках типов.

<a name="mocking-facades"></a>
## Фасады-заглушки

Юнит-тесты играют важную роль в том, почему фасады делают именно то, то они делают. На самом деле возможность тестирования - основная причина, по которой фасады вообще существуют. Эта тема подробнее раскрыта в [фасады-заглушки](/docs/testing#mocking-facades) соответствующем разделе документации.
