== Быстрый старт ==
{{Meta автор=из официальной документации, переводчик=Proger_XP, id переводчика=2, обновление=14.07.2013}}
{{Meta оригинал=doc4:quick}}

{{TOC}}

== Установка ==
Чтобы установить Laravel вам нужно выполнить эту команду в командной строке:
%%(sh)
  composer create-project laravel/laravel your-project-name --prefer-dist
%%

Либо можно скачать ((git:laravel/archive/master.zip архив хранилища)) с GitHub. Дальше ((http://getcomposer.org/ установите Composer)), запустите %%(sh) composer install%% в корневой папке вашего проекта. Она загрузит и установит зависимости фреймворка.

После установки изучите структуру папок. Папка **app** содержит подпапки, такие как **views**, **controllers** и **models**. Большая часть кода вашего приложения будет находиться где-то внутри них. Вы также можете посмотреть на содержимое %%(t)app/config%% и на настройки, которые доступны для изменения.

== ((#маршрут)) Маршрутизация ==
Для начала давайте создадим наш первый маршрут (//route//). В Laravel самый простой маршрут - функция-замыкание (//closure//). Откройте файл %%(t)app/routes.php%% и добавьте этот код в его конец:
%%(php)
  Route::get('users', function () {
    return 'Users!';
  });
%%

Теперь если вы перейдёте в браузере на адрес %%(t).../users%%, то должны увидеть текст %%Users!%%. Отлично! Вы только что создали свой первый маршрут.

Маршруты также могут быть привязаны к классу контроллера. Например:
%%(php)
  Route::get('users', 'UserController@getIndex');
%%

Этот маршрут сообщает Laravel, что запросы к %%(t)/users%% должны вызывать метод %%getIndex()%% класса %%UserController%%. Для дополнительной информации см. ((controllers раздел о контроллерах)).

== ((#шаблон)) Создаём шаблон ==
Давайте теперь создадим простой шаблон, или вид (от англ. //view//), чтобы показывать информацию о наших пользователях. Шаблоны находятся в %%(t)app/views%% и содержат HTML-код вашего приложения. Мы создадим два новых шаблона в этой папке: %%(t)layout.blade.php%% и %%(t)users.blade.php%%. Начнём с %%(t)layout.blade.php%%:
%%(html)
<html>
  <body>
    <h1>Laravel Quickstart</h1>

    @yield('content')
  </body>
</html>
%%

Теперь создадим %%(t)users.blade.php%%:
%%(html)
  @extends('layout')

  @section('content')
    Users!
  @stop
%%

Кое-что из этого кода, возможно, выглядит для вас весьма странно. Это из-за того, что мы используем шаблонизатор Laravel - //Blade//. Blade очень быстр благодаря тому, что это всего лишь набор регулярных выражений, которые преобразуют ваши шаблоны в чистый код на PHP. Blade позволяет наследовать шаблоны, а также добавляет "синтаксический сахар" к таким частоиспользуемым PHP-конструкциям, как **if** и **for**.  Для инфромации см. ((templates раздел о Blade)).

Теперь, когда у нас есть шаблоны, давайте используем их в нашем маршруте %%(t)/users%%. Вместо возврата простой строки %%Users!%% мы вернём экземпляр шаблона:
%%(php)
  Route::get('users', function () {
    return View::make('users');
  });
%%

Замечательно! Вы создали шаблон маршрута, который наследует разметку страницы (шаблон %%(t)layout%%). А теперь перейдём к работе с базой данных.

== Создаём миграцию ==
Для создания таблицы для хранения наших данных мы используем //систему миграций// Laravel. Миграции позволяют вам определять изменения в БД, используя выразительный синтаксис, а затем легко делиться ими с остальными членами вашей команды.

Для начала настроим соединение с БД. Все соединения настраиваются в файле %%(t)app/config/database.php%%. По умолчанию Laravel использует SQLite, которая находится в папке %%(t)app/database%%. Вы можете изменить опцию **driver** на %%(t)mysql%% и настроить соединение с MySQL в этом конфигурационном файле.

Для создания миграции мы воспользуемся ((artisan утилитой командной строки Artisan)). Выполните следующую команду в корневой папке вашего проекта:
%%(sh)
  php artisan migrate:make create_users_table
%%

Теперь найдите созданный файл миграции в папке %%(t)app/database/migrations%%. Он содержит класс с двумя методами: %%(t)up%% и %%(t)down%%. В методе **up** вам нужно произвести требуемые изменения в таблицах, а в методе **down** вам нужно их откатить.

Давайте создадим такую миграцию:
%%(php)
  public function up() {
    Schema::create('users', function ($table) {
      $table->increments('id');
      $table->string('email')->unique();
      $table->string('name');
      $table->timestamps();
    });
  }

  public function down() {
    Schema::drop('users');
  }
%%

Теперь мы можем применить миграцию через командную строку, используя команду **migrate**. Просто выполните её в корне проекта:
%%(sh)
  php artisan migrate
%%

Если вам нужно откатить миграцию - выполните команду %%(t)migrate:rollback%%. Теперь, когда у нас есть таблица, начнём загружать данные!

== Eloquent ORM ==
Laravel поставляется с замечательной [[ВП:ORM]] (!!(tl_note) механизм связывания записей БД с объектами PHP - //прим. пер.//!!) - //Eloquent//. Если вы программировали в библиотеке Ruby on Rails, то она покажется вам знакомой, так как Eloquent следует принципам ActiveRecord при взаимодействии с базами данных.

Для начала создадим //модель//. В Eloquent модель используется для запросов к соответствующей таблице в БД, а также представляет отдельную запись (//record//) внутри неё. Не беспокойтесь, скоро это станет куда понятнее! Модели обычно хранятся в папке %%(t)app/models%%. Создадим файл %%(t)User.php%% с таким кодом:
%%(php)
  class User extends Eloquent {}
%%

Заметьте, что нам не нужно указывать, какую таблицу нужно использовать. Eloquent следует множеству соглашений, одно из которых - то, что имя таблицы соответствует множественному числу имени класса её модели (!!(tl_note) user -> users - //прим. пер.//!!). Это очень удобно!

Добавьте новые записи в таблицу %%(t)users%%, используя ваш любимый инструмент для работы с БД, и мы посмотрим, как Eloquent позволяет их получить, а затем передать в ((#шаблон)).

Итак, изменим наш ((#маршрут)) %%(t)/users%%:
%%(php)
  Route::get('users', function () {
    $users = User::all();

    return View::make('users')->with('users', $users);
  });
%%

Посмотрим, что здесь происходит. Сперва мы получаем все записи в таблице %%(t)users%% через метод %%all()%% модели %%User%%. Дальше мы передаём эти записи шаблону через его метод %%with()%%. Этот метод принимает имя переменной и её значение и таким образом делает данные доступными внутри своего кода.

Отлично. Теперь мы готовы к тому, чтобы показать пользователей в нашем шаблоне!

== Отображаем данные ==
Теперь, когда мы сделали переменную %%(t)users%% доступной для нашего шаблона мы можем отобразить её таким образом:
%%(html)
  @extends('layout')

  @section('content')
    @foreach ($users as $user)
      <p>{{ $user->name }}</p>
    @endforeach
  @stop
%%

.(tl_note)
**Код выше открыт для XSS-атак** - Blade, как и простой код на PHP, не экранирует вывод, поэтому вам нужно следить, чтобы выводимые строки содержали экранированый HTML. Альтернативные шаблонизаторы, такие как ((тема:121 HTMLki)), делают это автоматически. - //прим. пер.//

Вам может быть интересно, куда подевались вызовы **echo**. Blade позволяет вам выводить строки, обрамляя их двойными фигурными скобками (%%(t){{ ... }}%%). Теперь вы можете перейти в браузере к своему маршруту и увидеть имена всех имеющихся пользователей.

Это только начало. В этом руководстве вы ознакомились с самыми основами Laravel, но у него есть ещё очень много интересных вещей, которые вам стоит узнать. Продолжайте читать документацию и глубже узнавать возможности, предоставляемые ((eloquent Eloquent)) и ((templates Blade)). А может вам больше интересны ((queues очереди)) и ((testing юнит-тесты))? Или же вам хочется размять мускулы с ((ioc контейнером IoC))? Выбор за вами!